name: Binary Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:

jobs:
  build-and-test:
    name: Build and Test Binary on ${{ matrix.os }}
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            binary_name: orochi
            binary_suffix: ""
            ldflags: ""
          - os: windows-latest
            binary_name: orochi
            binary_suffix: ".exe"
            ldflags: ""
          - os: macos-latest
            binary_name: orochi
            binary_suffix: ""
            ldflags: ""
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Go
      uses: actions/setup-go@v5
      with:
        go-version: '1.23'
    
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
    
    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: ~/.npm
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-
    
    - name: Build UI
      run: |
        cd web-ui
        npm ci
        npm run build
    
    - name: Build binary
      run: |
        go build -ldflags="${{ matrix.ldflags }}" -v -o ${{ matrix.binary_name }}${{ matrix.binary_suffix }} ./cmd/orochi
    
    - name: Upload binary
      uses: actions/upload-artifact@v4
      with:
        name: orochi-${{ matrix.os }}
        path: ${{ matrix.binary_name }}${{ matrix.binary_suffix }}
    
    # Basic smoke tests
    - name: Test --version
      run: |
        ./${{ matrix.binary_name }}${{ matrix.binary_suffix }} --version
      timeout-minutes: 1
    
    - name: Test --help
      run: |
        ./${{ matrix.binary_name }}${{ matrix.binary_suffix }} --help || true
      timeout-minutes: 1
    
    # Windows-specific binary validation
    - name: Validate Windows binary
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        Write-Host "=== Validating Windows Binary ==="
        
        # Check if binary has correct Windows subsystem
        try {
          # Simple check to ensure it's a Windows GUI or Console app
          $output = & ./${{ matrix.binary_name }}${{ matrix.binary_suffix }} --version 2>&1
          Write-Host "Version output: $output"
        } catch {
          Write-Host "Error during version check: $_"
          # This is expected for GUI apps, not an error
        }
        
        # Test with explicit console allocation
        Write-Host "`nTesting with explicit console..."
        try {
          $pinfo = New-Object System.Diagnostics.ProcessStartInfo
          $pinfo.FileName = (Get-Item "./${{ matrix.binary_name }}${{ matrix.binary_suffix }}").FullName
          $pinfo.Arguments = "--version"
          $pinfo.UseShellExecute = $false
          $pinfo.RedirectStandardOutput = $true
          $pinfo.RedirectStandardError = $true
          $pinfo.CreateNoWindow = $false
          
          $p = New-Object System.Diagnostics.Process
          $p.StartInfo = $pinfo
          $p.Start() | Out-Null
          $p.WaitForExit()
          
          $stdout = $p.StandardOutput.ReadToEnd()
          $stderr = $p.StandardError.ReadToEnd()
          
          Write-Host "Exit code: $($p.ExitCode)"
          Write-Host "Stdout: $stdout"
          Write-Host "Stderr: $stderr"
        } catch {
          Write-Host "Process start error: $_"
        }
    
    # Start server and test connectivity
    - name: Start server in background (Unix)
      if: matrix.os != 'windows-latest'
      shell: bash
      run: |
        ./${{ matrix.binary_name }}${{ matrix.binary_suffix }} --port 9999 > server.log 2>&1 &
        echo "SERVER_PID=$!" >> $GITHUB_ENV
        sleep 5
      timeout-minutes: 2
    
    - name: Start server in background (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        # Debug: Check if binary exists and is executable
        Write-Host "Checking binary: ./${{ matrix.binary_name }}${{ matrix.binary_suffix }}"
        if (Test-Path "./${{ matrix.binary_name }}${{ matrix.binary_suffix }}") {
          Write-Host "Binary found at: $(Get-Location)/${{ matrix.binary_name }}${{ matrix.binary_suffix }}"
          $fileInfo = Get-Item "./${{ matrix.binary_name }}${{ matrix.binary_suffix }}"
          Write-Host "File size: $($fileInfo.Length) bytes"
        } else {
          Write-Host "ERROR: Binary not found!"
          exit 1
        }
        
        # Start the process with more detailed error handling
        try {
          $process = Start-Process -FilePath "./${{ matrix.binary_name }}${{ matrix.binary_suffix }}" -ArgumentList "--port", "9999" -RedirectStandardOutput "server.log" -RedirectStandardError "server_error.log" -NoNewWindow -PassThru
          Write-Host "Process started with ID: $($process.Id)"
          
          # Check if process is still running after a short delay
          Start-Sleep -Seconds 2
          if ($process.HasExited) {
            Write-Host "ERROR: Process exited immediately with code: $($process.ExitCode)"
            Write-Host "=== Server Output ==="
            Get-Content server.log -ErrorAction SilentlyContinue
            Write-Host "=== Server Errors ==="
            Get-Content server_error.log -ErrorAction SilentlyContinue
            exit 1
          }
          
          # Windows needs more time to start
          Start-Sleep -Seconds 10
          
          # Final check if process is still running
          if ($process.HasExited) {
            Write-Host "ERROR: Process exited during startup with code: $($process.ExitCode)"
            Write-Host "=== Server Output ==="
            Get-Content server.log -ErrorAction SilentlyContinue
            Write-Host "=== Server Errors ==="
            Get-Content server_error.log -ErrorAction SilentlyContinue
            exit 1
          }
          
          Write-Host "Server appears to be running"
        } catch {
          Write-Host "ERROR starting process: $_"
          exit 1
        }
      timeout-minutes: 2
    
    - name: Check server is running (Unix)
      if: matrix.os != 'windows-latest'
      shell: bash
      run: |
        curl -f http://localhost:9999/api/health || (echo "Server health check failed" && cat server.log && exit 1)
      timeout-minutes: 1
    
    - name: Check server is running (Windows)
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        Write-Host "Checking server health at http://localhost:9999/api/health"
        
        # First check if port is listening
        try {
          $tcpConnection = Test-NetConnection -ComputerName localhost -Port 9999 -WarningAction SilentlyContinue
          if (-not $tcpConnection.TcpTestSucceeded) {
            Write-Host "ERROR: Port 9999 is not listening"
            Write-Host "=== Server Output ==="
            Get-Content server.log -ErrorAction SilentlyContinue
            Write-Host "=== Server Errors ==="
            Get-Content server_error.log -ErrorAction SilentlyContinue
            
            # Check if process is still running
            $orochi = Get-Process -Name ${{ matrix.binary_name }} -ErrorAction SilentlyContinue
            if ($orochi) {
              Write-Host "Process is running with PID: $($orochi.Id)"
            } else {
              Write-Host "Process is NOT running"
            }
            exit 1
          }
          Write-Host "Port 9999 is listening"
        } catch {
          Write-Host "Error checking port: $_"
        }
        
        # Now try the health check
        try {
          $response = Invoke-WebRequest -Uri "http://localhost:9999/api/health" -UseBasicParsing -TimeoutSec 10
          if ($response.StatusCode -ne 200) {
            throw "Health check failed with status: $($response.StatusCode)"
          }
          Write-Host "Health check passed with status: $($response.StatusCode)"
          Write-Host "Response content: $($response.Content)"
        } catch {
          Write-Host "Server health check failed: $_"
          Write-Host "=== Server Output ==="
          Get-Content server.log -ErrorAction SilentlyContinue
          Write-Host "=== Server Errors ==="
          Get-Content server_error.log -ErrorAction SilentlyContinue
          exit 1
        }
      timeout-minutes: 1
    
    - name: Stop server (Unix)
      if: always() && matrix.os != 'windows-latest'
      shell: bash
      run: |
        if [ ! -z "${SERVER_PID}" ]; then
          kill $SERVER_PID || true
        fi
        pkill -f "${{ matrix.binary_name }}" || true
    
    - name: Stop server (Windows)
      if: always() && matrix.os == 'windows-latest'  
      shell: pwsh
      run: |
        Get-Process -Name "${{ matrix.binary_name }}" -ErrorAction SilentlyContinue | Stop-Process -Force
    
    - name: Display server logs on failure
      if: failure()
      shell: bash
      run: |
        echo "=== Server Log ==="
        cat server.log || type server.log || echo "No server log found"
        echo "=== Server Error Log ==="
        cat server_error.log || type server_error.log || echo "No error log found"
        
        # Windows-specific: Check Event Viewer logs if available
        if [[ "${{ matrix.os }}" == "windows-latest" ]]; then
          echo "=== Recent Windows Application Events ==="
          powershell -Command "Get-EventLog -LogName Application -Newest 10 -EntryType Error,Warning | Where-Object {$_.Source -like '*orochi*' -or $_.Message -like '*orochi*'} | Format-List" || echo "Could not retrieve Windows event logs"
        fi

  test-downloaded-binaries:
    name: Test Downloaded Binary on ${{ matrix.os }}
    needs: build-and-test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            download_os: ubuntu-latest
            binary_name: orochi
            binary_suffix: ""
          - os: windows-latest
            download_os: windows-latest
            binary_name: orochi
            binary_suffix: ".exe"
          - os: macos-latest
            download_os: macos-latest
            binary_name: orochi
            binary_suffix: ""
    
    steps:
    - name: Download binary
      uses: actions/download-artifact@v4
      with:
        name: orochi-${{ matrix.download_os }}
    
    - name: Make binary executable (Unix)
      if: matrix.os != 'windows-latest'
      run: chmod +x ${{ matrix.binary_name }}${{ matrix.binary_suffix }}
    
    - name: Test downloaded binary --version
      run: |
        ./${{ matrix.binary_name }}${{ matrix.binary_suffix }} --version
      timeout-minutes: 1
    
    - name: Test downloaded binary --help
      run: |
        ./${{ matrix.binary_name }}${{ matrix.binary_suffix }} --help || true
      timeout-minutes: 1
    
    # Additional Windows-specific diagnostics
    - name: Windows binary diagnostics
      if: matrix.os == 'windows-latest'
      shell: pwsh
      run: |
        Write-Host "=== Windows Binary Diagnostics ==="
        $binary = "./${{ matrix.binary_name }}${{ matrix.binary_suffix }}"
        
        # Check file properties
        $file = Get-Item $binary
        Write-Host "File: $($file.FullName)"
        Write-Host "Size: $($file.Length) bytes"
        Write-Host "Creation Time: $($file.CreationTime)"
        Write-Host "Last Write Time: $($file.LastWriteTime)"
        
        # Check if it's a valid PE file
        try {
          $bytes = [System.IO.File]::ReadAllBytes($binary)
          if ($bytes[0] -eq 0x4D -and $bytes[1] -eq 0x5A) {
            Write-Host "Valid PE file signature found (MZ)"
          } else {
            Write-Host "WARNING: Invalid PE file signature"
          }
        } catch {
          Write-Host "Error reading file: $_"
        }
        
        # Try to get version info
        try {
          $versionInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($binary)
          Write-Host "FileVersion: $($versionInfo.FileVersion)"
          Write-Host "ProductVersion: $($versionInfo.ProductVersion)"
        } catch {
          Write-Host "No version info available"
        }
        
        # Check dependencies
        Write-Host "`n=== Checking Dependencies ==="
        try {
          # This will show if there are any obvious missing DLLs
          $proc = Start-Process -FilePath $binary -ArgumentList "--version" -NoNewWindow -PassThru -Wait
          Write-Host "Exit code from --version: $($proc.ExitCode)"
        } catch {
          Write-Host "Error running binary: $_"
        }